import{aV as Jt,aW as we,aX as lt,aY as Ft,aZ as V,a_ as wt,a$ as C,b0 as K,b1 as Kt,b2 as ge,b3 as Lt,b4 as ye,b5 as Ct}from"./index.846ecf1a.js";function Nt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function me(t){if(typeof t!="boolean")throw new Error(`Expected boolean, not ${t}`)}function te(t,...n){if(!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(n.length>0&&!n.includes(t.length))throw new TypeError(`Expected Uint8Array of length ${n}, not of length=${t.length}`)}function xe(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Nt(t.outputLen),Nt(t.blockLen)}function pe(t,n=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(n&&t.finished)throw new Error("Hash#digest() has already been called")}function Ee(t,n){te(t);const e=n.outputLen;if(t.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}const it={number:Nt,bool:me,bytes:te,hash:xe,exists:pe,output:Ee},It=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _t=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),M=(t,n)=>t<<32-n|t>>>n,Be=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Be)throw new Error("Non little-endian hardware is not supported");Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function ve(t){if(typeof t!="string")throw new TypeError(`utf8ToBytes expected string, got ${typeof t}`);return new TextEncoder().encode(t)}function kt(t){if(typeof t=="string"&&(t=ve(t)),!(t instanceof Uint8Array))throw new TypeError(`Expected input type is Uint8Array (got ${typeof t})`);return t}function Se(...t){if(!t.every(r=>r instanceof Uint8Array))throw new Error("Uint8Array list expected");if(t.length===1)return t[0];const n=t.reduce((r,s)=>r+s.length,0),e=new Uint8Array(n);for(let r=0,s=0;r<t.length;r++){const o=t[r];e.set(o,s),s+=o.length}return e}class ee{clone(){return this._cloneInto()}}function ne(t){const n=r=>t().update(kt(r)).digest(),e=t();return n.outputLen=e.outputLen,n.blockLen=e.blockLen,n.create=()=>t(),n}function re(t=32){if(It&&typeof It.getRandomValues=="function")return It.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}function Ae(t,n,e,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(n,e,r);const s=BigInt(32),o=BigInt(4294967295),f=Number(e>>s&o),c=Number(e&o),i=r?4:0,a=r?0:4;t.setUint32(n+i,f,r),t.setUint32(n+a,c,r)}class Ie extends ee{constructor(n,e,r,s){super(),this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=_t(this.buffer)}update(n){it.exists(this);const{view:e,buffer:r,blockLen:s}=this;n=kt(n);const o=n.length;for(let f=0;f<o;){const c=Math.min(s-this.pos,o-f);if(c===s){const i=_t(n);for(;s<=o-f;f+=s)this.process(i,f);continue}r.set(n.subarray(f,f+c),this.pos),this.pos+=c,f+=c,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){it.exists(this),it.output(n,this),this.finished=!0;const{buffer:e,view:r,blockLen:s,isLE:o}=this;let{pos:f}=this;e[f++]=128,this.buffer.subarray(f).fill(0),this.padOffset>s-f&&(this.process(r,0),f=0);for(let l=f;l<s;l++)e[l]=0;Ae(r,s-8,BigInt(this.length*8),o),this.process(r,0);const c=_t(n),i=this.outputLen;if(i%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=i/4,b=this.get();if(a>b.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<a;l++)c.setUint32(4*l,b[l],o)}digest(){const{buffer:n,outputLen:e}=this;this.digestInto(n);const r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:e,buffer:r,length:s,finished:o,destroyed:f,pos:c}=this;return n.length=s,n.pos=c,n.finished=o,n.destroyed=f,s%e&&n.buffer.set(r),n}}const _e=(t,n,e)=>t&n^~t&e,qe=(t,n,e)=>t&n^t&e^n&e,Oe=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),tt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),et=new Uint32Array(64);class se extends Ie{constructor(){super(64,32,8,!1),this.A=tt[0]|0,this.B=tt[1]|0,this.C=tt[2]|0,this.D=tt[3]|0,this.E=tt[4]|0,this.F=tt[5]|0,this.G=tt[6]|0,this.H=tt[7]|0}get(){const{A:n,B:e,C:r,D:s,E:o,F:f,G:c,H:i}=this;return[n,e,r,s,o,f,c,i]}set(n,e,r,s,o,f,c,i){this.A=n|0,this.B=e|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=f|0,this.G=c|0,this.H=i|0}process(n,e){for(let l=0;l<16;l++,e+=4)et[l]=n.getUint32(e,!1);for(let l=16;l<64;l++){const B=et[l-15],p=et[l-2],g=M(B,7)^M(B,18)^B>>>3,u=M(p,17)^M(p,19)^p>>>10;et[l]=u+et[l-7]+g+et[l-16]|0}let{A:r,B:s,C:o,D:f,E:c,F:i,G:a,H:b}=this;for(let l=0;l<64;l++){const B=M(c,6)^M(c,11)^M(c,25),p=b+B+_e(c,i,a)+Oe[l]+et[l]|0,u=(M(r,2)^M(r,13)^M(r,22))+qe(r,s,o)|0;b=a,a=i,i=c,c=f+p|0,f=o,o=s,s=r,r=p+u|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,f=f+this.D|0,c=c+this.E|0,i=i+this.F|0,a=a+this.G|0,b=b+this.H|0,this.set(r,s,o,f,c,i,a,b)}roundClean(){et.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class Le extends se{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const yt=ne(()=>new se);ne(()=>new Le);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const R=BigInt(0),T=BigInt(1),ot=BigInt(2),Ne=BigInt(3),Tt=BigInt(4),jt=BigInt(5),Gt=BigInt(8);BigInt(9);BigInt(16);function H(t,n){const e=t%n;return e>=R?e:n+e}function Te(t,n,e){if(e<=R||n<R)throw new Error("Expected power/modulo > 0");if(e===T)return R;let r=T;for(;n>R;)n&T&&(r=r*t%e),t=t*t%e,n>>=T;return r}function Y(t,n,e){let r=t;for(;n-- >R;)r*=r,r%=e;return r}function Ut(t,n){if(t===R||n<=R)throw new Error(`invert: expected positive integers, got n=${t} mod=${n}`);let e=H(t,n),r=n,s=R,o=T;for(;e!==R;){const c=r/e,i=r%e,a=s-o*c;r=e,e=i,s=o,o=a}if(r!==T)throw new Error("invert: does not exist");return H(s,n)}function Ue(t){const n=(t-T)/ot;let e,r,s;for(e=t-T,r=0;e%ot===R;e/=ot,r++);for(s=ot;s<t&&Te(s,n,t)!==t-T;s++);if(r===1){const f=(t+T)/Tt;return function(i,a){const b=i.pow(a,f);if(!i.eql(i.sqr(b),a))throw new Error("Cannot find square root");return b}}const o=(e+T)/ot;return function(c,i){if(c.pow(i,n)===c.neg(c.ONE))throw new Error("Cannot find square root");let a=r,b=c.pow(c.mul(c.ONE,s),e),l=c.pow(i,o),B=c.pow(i,e);for(;!c.eql(B,c.ONE);){if(c.eql(B,c.ZERO))return c.ZERO;let p=1;for(let u=c.sqr(B);p<a&&!c.eql(u,c.ONE);p++)u=c.sqr(u);const g=c.pow(b,T<<BigInt(a-p-1));b=c.sqr(g),l=c.mul(l,g),B=c.mul(B,b),a=p}return l}}function He(t){if(t%Tt===Ne){const n=(t+T)/Tt;return function(r,s){const o=r.pow(s,n);if(!r.eql(r.sqr(o),s))throw new Error("Cannot find square root");return o}}if(t%Gt===jt){const n=(t-jt)/Gt;return function(r,s){const o=r.mul(s,ot),f=r.pow(o,n),c=r.mul(s,f),i=r.mul(r.mul(c,ot),f),a=r.mul(c,r.sub(i,r.ONE));if(!r.eql(r.sqr(a),s))throw new Error("Cannot find square root");return a}}return Ue(t)}const Re=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function oe(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Re.reduce((r,s)=>(r[s]="function",r),n);return wt(t,e)}function Ce(t,n,e){if(e<R)throw new Error("Expected power > 0");if(e===R)return t.ONE;if(e===T)return n;let r=t.ONE,s=n;for(;e>R;)e&T&&(r=t.mul(r,s)),s=t.sqr(s),e>>=T;return r}function ke(t,n){const e=new Array(n.length),r=n.reduce((o,f,c)=>t.is0(f)?o:(e[c]=o,t.mul(o,f)),t.ONE),s=t.inv(r);return n.reduceRight((o,f,c)=>t.is0(f)?o:(e[c]=t.mul(o,e[c]),t.mul(o,f)),s),e}function Vt(t,n){const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function Ve(t,n,e=!1,r={}){if(t<=R)throw new Error(`Expected Fp ORDER > 0, got ${t}`);const{nBitLength:s,nByteLength:o}=Vt(t,n);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const f=He(t),c=Object.freeze({ORDER:t,BITS:s,BYTES:o,MASK:Jt(s),ZERO:R,ONE:T,create:i=>H(i,t),isValid:i=>{if(typeof i!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof i}`);return R<=i&&i<t},is0:i=>i===R,isOdd:i=>(i&T)===T,neg:i=>H(-i,t),eql:(i,a)=>i===a,sqr:i=>H(i*i,t),add:(i,a)=>H(i+a,t),sub:(i,a)=>H(i-a,t),mul:(i,a)=>H(i*a,t),pow:(i,a)=>Ce(c,i,a),div:(i,a)=>H(i*Ut(a,t),t),sqrN:i=>i*i,addN:(i,a)=>i+a,subN:(i,a)=>i-a,mulN:(i,a)=>i*a,inv:i=>Ut(i,t),sqrt:r.sqrt||(i=>f(c,i)),invertBatch:i=>ke(c,i),cmov:(i,a,b)=>b?a:i,toBytes:i=>e?we(i,o):lt(i,o),fromBytes:i=>{if(i.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${i.length}`);return e?Ft(i):V(i)}});return Object.freeze(c)}function Ze(t,n,e=!1){t=C("privateHash",t);const r=t.length,s=Vt(n).nByteLength+8;if(s<24||r<s||r>1024)throw new Error(`hashToPrivateScalar: expected ${s}-1024 bytes of input, got ${r}`);const o=e?Ft(t):V(t);return H(o,n-T)+T}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const $e=BigInt(0),qt=BigInt(1);function Pe(t,n){const e=(s,o)=>{const f=o.negate();return s?f:o},r=s=>{const o=Math.ceil(n/s)+1,f=2**(s-1);return{windows:o,windowSize:f}};return{constTimeNegate:e,unsafeLadder(s,o){let f=t.ZERO,c=s;for(;o>$e;)o&qt&&(f=f.add(c)),c=c.double(),o>>=qt;return f},precomputeWindow(s,o){const{windows:f,windowSize:c}=r(o),i=[];let a=s,b=a;for(let l=0;l<f;l++){b=a,i.push(b);for(let B=1;B<c;B++)b=b.add(a),i.push(b);a=b.double()}return i},wNAF(s,o,f){const{windows:c,windowSize:i}=r(s);let a=t.ZERO,b=t.BASE;const l=BigInt(2**s-1),B=2**s,p=BigInt(s);for(let g=0;g<c;g++){const u=g*i;let d=Number(f&l);f>>=p,d>i&&(d-=B,f+=qt);const h=u,m=u+Math.abs(d)-1,E=g%2!==0,_=d<0;d===0?b=b.add(e(E,o[h])):a=a.add(e(_,o[m]))}return{p:a,f:b}},wNAFCached(s,o,f,c){const i=s._WINDOW_SIZE||1;let a=o.get(s);return a||(a=this.precomputeWindow(s,i),i!==1&&o.set(s,c(a))),this.wNAF(i,a,f)}}}function ie(t){return oe(t.Fp),wt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Vt(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ze(t){const n=ie(t);wt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:s}=n;if(e){if(!r.eql(s,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:De,hexToBytes:Ye}=ye,ct={Err:class extends Error{constructor(n=""){super(n)}},_parseInt(t){const{Err:n}=ct;if(t.length<2||t[0]!==2)throw new n("Invalid signature integer tag");const e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new n("Invalid signature integer: wrong length");if(r[0]&128)throw new n("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new n("Invalid signature integer: unnecessary leading zero");return{d:De(r),l:t.subarray(e+2)}},toSig(t){const{Err:n}=ct,e=typeof t=="string"?Ye(t):t;if(!(e instanceof Uint8Array))throw new Error("ui8a expected");let r=e.length;if(r<2||e[0]!=48)throw new n("Invalid signature tag");if(e[1]!==r-2)throw new n("Invalid signature: incorrect length");const{d:s,l:o}=ct._parseInt(e.subarray(2)),{d:f,l:c}=ct._parseInt(o);if(c.length)throw new n("Invalid signature: left bytes after parsing");return{r:s,s:f}},hexFromSig(t){const n=a=>Number.parseInt(a[0],16)&8?"00"+a:a,e=a=>{const b=a.toString(16);return b.length&1?`0${b}`:b},r=n(e(t.s)),s=n(e(t.r)),o=r.length/2,f=s.length/2,c=e(o),i=e(f);return`30${e(f+o+4)}02${i}${s}02${c}${r}`}},j=BigInt(0),U=BigInt(1),W=BigInt(2),mt=BigInt(3),Mt=BigInt(4);function Ke(t){const n=ze(t),{Fp:e}=n,r=n.toBytes||((g,u,d)=>{const h=u.toAffine();return K(Uint8Array.from([4]),e.toBytes(h.x),e.toBytes(h.y))}),s=n.fromBytes||(g=>{const u=g.subarray(1),d=e.fromBytes(u.subarray(0,e.BYTES)),h=e.fromBytes(u.subarray(e.BYTES,2*e.BYTES));return{x:d,y:h}});function o(g){const{a:u,b:d}=n,h=e.sqr(g),m=e.mul(h,g);return e.add(e.add(m,e.mul(g,u)),d)}if(!e.eql(e.sqr(n.Gy),o(n.Gx)))throw new Error("bad generator point: equation left != right");function f(g){return typeof g=="bigint"&&j<g&&g<n.n}function c(g){if(!f(g))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function i(g){const{allowedPrivateKeyLengths:u,nByteLength:d,wrapPrivateKey:h,n:m}=n;if(u&&typeof g!="bigint"){if(g instanceof Uint8Array&&(g=Lt(g)),typeof g!="string"||!u.includes(g.length))throw new Error("Invalid key");g=g.padStart(d*2,"0")}let E;try{E=typeof g=="bigint"?g:V(C("private key",g,d))}catch{throw new Error(`private key must be ${d} bytes, hex or bigint, not ${typeof g}`)}return h&&(E=H(E,m)),c(E),E}const a=new Map;function b(g){if(!(g instanceof l))throw new Error("ProjectivePoint expected")}class l{constructor(u,d,h){if(this.px=u,this.py=d,this.pz=h,u==null||!e.isValid(u))throw new Error("x required");if(d==null||!e.isValid(d))throw new Error("y required");if(h==null||!e.isValid(h))throw new Error("z required")}static fromAffine(u){const{x:d,y:h}=u||{};if(!u||!e.isValid(d)||!e.isValid(h))throw new Error("invalid affine point");if(u instanceof l)throw new Error("projective point not allowed");const m=E=>e.eql(E,e.ZERO);return m(d)&&m(h)?l.ZERO:new l(d,h,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){const d=e.invertBatch(u.map(h=>h.pz));return u.map((h,m)=>h.toAffine(d[m])).map(l.fromAffine)}static fromHex(u){const d=l.fromAffine(s(C("pointHex",u)));return d.assertValidity(),d}static fromPrivateKey(u){return l.BASE.multiply(i(u))}_setWindowSize(u){this._WINDOW_SIZE=u,a.delete(this)}assertValidity(){if(this.is0()){if(n.allowInfinityPoint)return;throw new Error("bad point: ZERO")}const{x:u,y:d}=this.toAffine();if(!e.isValid(u)||!e.isValid(d))throw new Error("bad point: x or y not FE");const h=e.sqr(d),m=o(u);if(!e.eql(h,m))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:u}=this.toAffine();if(e.isOdd)return!e.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){b(u);const{px:d,py:h,pz:m}=this,{px:E,py:_,pz:S}=u,x=e.eql(e.mul(d,S),e.mul(E,m)),v=e.eql(e.mul(h,S),e.mul(_,m));return x&&v}negate(){return new l(this.px,e.neg(this.py),this.pz)}double(){const{a:u,b:d}=n,h=e.mul(d,mt),{px:m,py:E,pz:_}=this;let S=e.ZERO,x=e.ZERO,v=e.ZERO,I=e.mul(m,m),z=e.mul(E,E),N=e.mul(_,_),q=e.mul(m,E);return q=e.add(q,q),v=e.mul(m,_),v=e.add(v,v),S=e.mul(u,v),x=e.mul(h,N),x=e.add(S,x),S=e.sub(z,x),x=e.add(z,x),x=e.mul(S,x),S=e.mul(q,S),v=e.mul(h,v),N=e.mul(u,N),q=e.sub(I,N),q=e.mul(u,q),q=e.add(q,v),v=e.add(I,I),I=e.add(v,I),I=e.add(I,N),I=e.mul(I,q),x=e.add(x,I),N=e.mul(E,_),N=e.add(N,N),I=e.mul(N,q),S=e.sub(S,I),v=e.mul(N,z),v=e.add(v,v),v=e.add(v,v),new l(S,x,v)}add(u){b(u);const{px:d,py:h,pz:m}=this,{px:E,py:_,pz:S}=u;let x=e.ZERO,v=e.ZERO,I=e.ZERO;const z=n.a,N=e.mul(n.b,mt);let q=e.mul(d,E),Z=e.mul(h,_),$=e.mul(m,S),X=e.add(d,h),w=e.add(E,_);X=e.mul(X,w),w=e.add(q,Z),X=e.sub(X,w),w=e.add(d,m);let y=e.add(E,S);return w=e.mul(w,y),y=e.add(q,$),w=e.sub(w,y),y=e.add(h,m),x=e.add(_,S),y=e.mul(y,x),x=e.add(Z,$),y=e.sub(y,x),I=e.mul(z,w),x=e.mul(N,$),I=e.add(x,I),x=e.sub(Z,I),I=e.add(Z,I),v=e.mul(x,I),Z=e.add(q,q),Z=e.add(Z,q),$=e.mul(z,$),w=e.mul(N,w),Z=e.add(Z,$),$=e.sub(q,$),$=e.mul(z,$),w=e.add(w,$),q=e.mul(Z,w),v=e.add(v,q),q=e.mul(y,w),x=e.mul(X,x),x=e.sub(x,q),q=e.mul(X,Z),I=e.mul(y,I),I=e.add(I,q),new l(x,v,I)}subtract(u){return this.add(u.negate())}is0(){return this.equals(l.ZERO)}wNAF(u){return p.wNAFCached(this,a,u,d=>{const h=e.invertBatch(d.map(m=>m.pz));return d.map((m,E)=>m.toAffine(h[E])).map(l.fromAffine)})}multiplyUnsafe(u){const d=l.ZERO;if(u===j)return d;if(c(u),u===U)return this;const{endo:h}=n;if(!h)return p.unsafeLadder(this,u);let{k1neg:m,k1:E,k2neg:_,k2:S}=h.splitScalar(u),x=d,v=d,I=this;for(;E>j||S>j;)E&U&&(x=x.add(I)),S&U&&(v=v.add(I)),I=I.double(),E>>=U,S>>=U;return m&&(x=x.negate()),_&&(v=v.negate()),v=new l(e.mul(v.px,h.beta),v.py,v.pz),x.add(v)}multiply(u){c(u);let d=u,h,m;const{endo:E}=n;if(E){const{k1neg:_,k1:S,k2neg:x,k2:v}=E.splitScalar(d);let{p:I,f:z}=this.wNAF(S),{p:N,f:q}=this.wNAF(v);I=p.constTimeNegate(_,I),N=p.constTimeNegate(x,N),N=new l(e.mul(N.px,E.beta),N.py,N.pz),h=I.add(N),m=z.add(q)}else{const{p:_,f:S}=this.wNAF(d);h=_,m=S}return l.normalizeZ([h,m])[0]}multiplyAndAddUnsafe(u,d,h){const m=l.BASE,E=(S,x)=>x===j||x===U||!S.equals(m)?S.multiplyUnsafe(x):S.multiply(x),_=E(this,d).add(E(u,h));return _.is0()?void 0:_}toAffine(u){const{px:d,py:h,pz:m}=this,E=this.is0();u==null&&(u=E?e.ONE:e.inv(m));const _=e.mul(d,u),S=e.mul(h,u),x=e.mul(m,u);if(E)return{x:e.ZERO,y:e.ZERO};if(!e.eql(x,e.ONE))throw new Error("invZ was invalid");return{x:_,y:S}}isTorsionFree(){const{h:u,isTorsionFree:d}=n;if(u===U)return!0;if(d)return d(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:u,clearCofactor:d}=n;return u===U?this:d?d(l,this):this.multiplyUnsafe(n.h)}toRawBytes(u=!0){return this.assertValidity(),r(l,this,u)}toHex(u=!0){return Lt(this.toRawBytes(u))}}l.BASE=new l(n.Gx,n.Gy,e.ONE),l.ZERO=new l(e.ZERO,e.ONE,e.ZERO);const B=n.nBitLength,p=Pe(l,n.endo?Math.ceil(B/2):B);return{CURVE:n,ProjectivePoint:l,normPrivateKeyToScalar:i,weierstrassEquation:o,isWithinCurveOrder:f}}function je(t){const n=ie(t);return wt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function Ge(t){const n=je(t),{Fp:e,n:r}=n,s=e.BYTES+1,o=2*e.BYTES+1;function f(w){return j<w&&w<e.ORDER}function c(w){return H(w,r)}function i(w){return Ut(w,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:b,weierstrassEquation:l,isWithinCurveOrder:B}=Ke({...n,toBytes(w,y,A){const L=y.toAffine(),O=e.toBytes(L.x),k=K;return A?k(Uint8Array.from([y.hasEvenY()?2:3]),O):k(Uint8Array.from([4]),O,e.toBytes(L.y))},fromBytes(w){const y=w.length,A=w[0],L=w.subarray(1);if(y===s&&(A===2||A===3)){const O=V(L);if(!f(O))throw new Error("Point is not on curve");const k=l(O);let D=e.sqrt(k);const P=(D&U)===U;return(A&1)===1!==P&&(D=e.neg(D)),{x:O,y:D}}else if(y===o&&A===4){const O=e.fromBytes(L.subarray(0,e.BYTES)),k=e.fromBytes(L.subarray(e.BYTES,2*e.BYTES));return{x:O,y:k}}else throw new Error(`Point of length ${y} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)}}),p=w=>Lt(lt(w,n.nByteLength));function g(w){const y=r>>U;return w>y}function u(w){return g(w)?c(-w):w}const d=(w,y,A)=>V(w.slice(y,A));class h{constructor(y,A,L){this.r=y,this.s=A,this.recovery=L,this.assertValidity()}static fromCompact(y){const A=n.nByteLength;return y=C("compactSignature",y,A*2),new h(d(y,0,A),d(y,A,2*A))}static fromDER(y){const{r:A,s:L}=ct.toSig(C("DER",y));return new h(A,L)}assertValidity(){if(!B(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!B(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(y){return new h(this.r,this.s,y)}recoverPublicKey(y){const{r:A,s:L,recovery:O}=this,k=v(C("msgHash",y));if(O==null||![0,1,2,3].includes(O))throw new Error("recovery id invalid");const D=O===2||O===3?A+n.n:A;if(D>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const P=(O&1)===0?"02":"03",Q=a.fromHex(P+p(D)),J=i(D),ft=c(-k*J),dt=c(L*J),F=a.BASE.multiplyAndAddUnsafe(Q,ft,dt);if(!F)throw new Error("point at infinify");return F.assertValidity(),F}hasHighS(){return g(this.s)}normalizeS(){return this.hasHighS()?new h(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return Kt(this.toDERHex())}toDERHex(){return ct.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Kt(this.toCompactHex())}toCompactHex(){return p(this.r)+p(this.s)}}const m={isValidPrivateKey(w){try{return b(w),!0}catch{return!1}},normPrivateKeyToScalar:b,randomPrivateKey:()=>{const w=n.randomBytes(e.BYTES+8),y=Ze(w,r);return lt(y,n.nByteLength)},precompute(w=8,y=a.BASE){return y._setWindowSize(w),y.multiply(BigInt(3)),y}};function E(w,y=!0){return a.fromPrivateKey(w).toRawBytes(y)}function _(w){const y=w instanceof Uint8Array,A=typeof w=="string",L=(y||A)&&w.length;return y?L===s||L===o:A?L===2*s||L===2*o:w instanceof a}function S(w,y,A=!0){if(_(w))throw new Error("first arg must be private key");if(!_(y))throw new Error("second arg must be public key");return a.fromHex(y).multiply(b(w)).toRawBytes(A)}const x=n.bits2int||function(w){const y=V(w),A=w.length*8-n.nBitLength;return A>0?y>>BigInt(A):y},v=n.bits2int_modN||function(w){return c(x(w))},I=Jt(n.nBitLength);function z(w){if(typeof w!="bigint")throw new Error("bigint expected");if(!(j<=w&&w<I))throw new Error(`bigint expected < 2^${n.nBitLength}`);return lt(w,n.nByteLength)}function N(w,y,A=q){if(["recovered","canonical"].some(st=>st in A))throw new Error("sign() legacy options not supported");const{hash:L,randomBytes:O}=n;let{lowS:k,prehash:D,extraEntropy:P}=A;k==null&&(k=!0),w=C("msgHash",w),D&&(w=C("prehashed msgHash",L(w)));const Q=v(w),J=b(y),ft=[z(J),z(Q)];if(P!=null){const st=P===!0?O(e.BYTES):P;ft.push(C("extraEntropy",st,e.BYTES))}const dt=K(...ft),F=Q;function At(st){const at=x(st);if(!B(at))return;const zt=i(at),G=a.BASE.multiply(at).toAffine(),ut=c(G.x);if(ut===j)return;const gt=c(zt*c(F+ut*J));if(gt===j)return;let Dt=(G.x===ut?0:2)|Number(G.y&U),Yt=gt;return k&&g(gt)&&(Yt=u(gt),Dt^=1),new h(ut,Yt,Dt)}return{seed:dt,k2sig:At}}const q={lowS:n.lowS,prehash:!1},Z={lowS:n.lowS,prehash:!1};function $(w,y,A=q){const{seed:L,k2sig:O}=N(w,y,A);return ge(n.hash.outputLen,n.nByteLength,n.hmac)(L,O)}a.BASE._setWindowSize(8);function X(w,y,A,L=Z){const O=w;if(y=C("msgHash",y),A=C("publicKey",A),"strict"in L)throw new Error("options.strict was renamed to lowS");const{lowS:k,prehash:D}=L;let P,Q;try{if(typeof O=="string"||O instanceof Uint8Array)try{P=h.fromDER(O)}catch(G){if(!(G instanceof ct.Err))throw G;P=h.fromCompact(O)}else if(typeof O=="object"&&typeof O.r=="bigint"&&typeof O.s=="bigint"){const{r:G,s:ut}=O;P=new h(G,ut)}else throw new Error("PARSE");Q=a.fromHex(A)}catch(G){if(G.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(k&&P.hasHighS())return!1;D&&(y=n.hash(y));const{r:J,s:ft}=P,dt=v(y),F=i(ft),At=c(dt*F),st=c(J*F),at=a.BASE.multiplyAndAddUnsafe(Q,At,st)?.toAffine();return at?c(at.x)===J:!1}return{CURVE:n,getPublicKey:E,getSharedSecret:S,sign:$,verify:X,ProjectivePoint:a,Signature:h,utils:m}}function Me(t,n){const e=t.ORDER;let r=j;for(let B=e-U;B%W===j;B/=W)r+=U;const s=r,o=(e-U)/W**s,f=(o-U)/W,c=W**s-U,i=W**(s-U),a=t.pow(n,o),b=t.pow(n,(o+U)/W);let l=(B,p)=>{let g=a,u=t.pow(p,c),d=t.sqr(u);d=t.mul(d,p);let h=t.mul(B,d);h=t.pow(h,f),h=t.mul(h,u),u=t.mul(h,p),d=t.mul(h,B);let m=t.mul(d,u);h=t.pow(m,i);let E=t.eql(h,t.ONE);u=t.mul(d,b),h=t.mul(m,g),d=t.cmov(u,d,E),m=t.cmov(h,m,E);for(let _=s;_>U;_--){let S=W**(_-W),x=t.pow(m,S);const v=t.eql(x,t.ONE);u=t.mul(d,g),g=t.mul(g,g),x=t.mul(m,g),d=t.cmov(u,d,v),m=t.cmov(x,m,v)}return{isValid:E,value:d}};if(t.ORDER%Mt===mt){const B=(t.ORDER-mt)/Mt,p=t.sqrt(t.neg(n));l=(g,u)=>{let d=t.sqr(u);const h=t.mul(g,u);d=t.mul(d,h);let m=t.pow(d,B);m=t.mul(m,h);const E=t.mul(m,p),_=t.mul(t.sqr(m),u),S=t.eql(_,g);let x=t.cmov(E,m,S);return{isValid:S,value:x}}}return l}function We(t,n){if(oe(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=Me(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let s,o,f,c,i,a,b,l;s=t.sqr(r),s=t.mul(s,n.Z),o=t.sqr(s),o=t.add(o,s),f=t.add(o,t.ONE),f=t.mul(f,n.B),c=t.cmov(n.Z,t.neg(o),!t.eql(o,t.ZERO)),c=t.mul(c,n.A),o=t.sqr(f),a=t.sqr(c),i=t.mul(a,n.A),o=t.add(o,i),o=t.mul(o,f),a=t.mul(a,c),i=t.mul(a,n.B),o=t.add(o,i),b=t.mul(s,f);const{isValid:B,value:p}=e(o,a);l=t.mul(s,r),l=t.mul(l,p),b=t.cmov(b,f,B),l=t.cmov(l,p,B);const g=t.isOdd(r)===t.isOdd(l);return l=t.cmov(t.neg(l),l,g),b=t.div(b,c),{x:b,y:l}}}function Xe(t){if(t instanceof Uint8Array)return t;if(typeof t=="string")return Ct(t);throw new Error("DST must be Uint8Array or string")}const Qe=V;function nt(t,n){if(t<0||t>=1<<8*n)throw new Error(`bad I2OSP call: value=${t} length=${n}`);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function Je(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function ht(t){if(!(t instanceof Uint8Array))throw new Error("Uint8Array expected")}function Zt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function Fe(t,n,e,r){ht(t),ht(n),Zt(e),n.length>255&&(n=r(K(Ct("H2C-OVERSIZE-DST-"),n)));const{outputLen:s,blockLen:o}=r,f=Math.ceil(e/s);if(f>255)throw new Error("Invalid xmd length");const c=K(n,nt(n.length,1)),i=nt(0,o),a=nt(e,2),b=new Array(f),l=r(K(i,t,a,nt(0,1),c));b[0]=r(K(l,nt(1,1),c));for(let p=1;p<=f;p++){const g=[Je(l,b[p-1]),nt(p+1,1),c];b[p]=r(K(...g))}return K(...b).slice(0,e)}function tn(t,n,e,r,s){if(ht(t),ht(n),Zt(e),n.length>255){const o=Math.ceil(2*r/8);n=s.create({dkLen:o}).update(Ct("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:e}).update(t).update(nt(e,2)).update(n).update(nt(n.length,1)).digest()}function Wt(t,n,e){wt(e,{DST:"string",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:s,m:o,hash:f,expand:c,DST:i}=e;ht(t),Zt(n);const a=Xe(i),b=r.toString(2).length,l=Math.ceil((b+s)/8),B=n*o*l;let p;if(c==="xmd")p=Fe(t,a,B,f);else if(c==="xof")p=tn(t,a,B,s,f);else if(c==="_internal_pass")p=t;else throw new Error('expand must be "xmd" or "xof"');const g=new Array(n);for(let u=0;u<n;u++){const d=new Array(o);for(let h=0;h<o;h++){const m=l*(h+u*o),E=p.subarray(m,m+l);d[h]=H(Qe(E),r)}g[u]=d}return g}function en(t,n){const e=n.map(r=>Array.from(r).reverse());return(r,s)=>{const[o,f,c,i]=e.map(a=>a.reduce((b,l)=>t.add(t.mul(b,r),l)));return r=t.div(o,f),s=t.mul(s,t.div(c,i)),{x:r,y:s}}}function nn(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,s){const o=Wt(r,2,{...e,DST:e.DST,...s}),f=t.fromAffine(n(o[0])),c=t.fromAffine(n(o[1])),i=f.add(c).clearCofactor();return i.assertValidity(),i},encodeToCurve(r,s){const o=Wt(r,1,{...e,DST:e.encodeDST,...s}),f=t.fromAffine(n(o[0])).clearCofactor();return f.assertValidity(),f}}}class ce extends ee{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,it.hash(n);const r=kt(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new TypeError("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?n.create().update(r).digest():r);for(let f=0;f<o.length;f++)o[f]^=54;this.iHash.update(o),this.oHash=n.create();for(let f=0;f<o.length;f++)o[f]^=106;this.oHash.update(o),o.fill(0)}update(n){return it.exists(this),this.iHash.update(n),this}digestInto(n){it.exists(this),it.bytes(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:s,destroyed:o,blockLen:f,outputLen:c}=this;return n=n,n.finished=s,n.destroyed=o,n.blockLen=f,n.outputLen=c,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const fe=(t,n,e)=>new ce(t,n).update(e).digest();fe.create=(t,n)=>new ce(t,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function rn(t){return{hash:t,hmac:(n,...e)=>fe(t,n,Se(...e)),randomBytes:re}}function sn(t,n){const e=r=>Ge({...t,...rn(r)});return Object.freeze({...e(n),create:e})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Bt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),xt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),ae=BigInt(1),pt=BigInt(2),Xt=(t,n)=>(t+n/pt)/n;function ue(t){const n=Bt,e=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),f=BigInt(23),c=BigInt(44),i=BigInt(88),a=t*t*t%n,b=a*a*t%n,l=Y(b,e,n)*b%n,B=Y(l,e,n)*b%n,p=Y(B,pt,n)*a%n,g=Y(p,s,n)*p%n,u=Y(g,o,n)*g%n,d=Y(u,c,n)*u%n,h=Y(d,i,n)*d%n,m=Y(h,c,n)*u%n,E=Y(m,e,n)*b%n,_=Y(E,f,n)*g%n,S=Y(_,r,n)*a%n,x=Y(S,pt,n);if(!rt.eql(rt.sqr(x),t))throw new Error("Cannot find square root");return x}const rt=Ve(Bt,void 0,void 0,{sqrt:ue}),vt=sn({a:BigInt(0),b:BigInt(7),Fp:rt,n:xt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const n=xt,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-ae*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=e,f=BigInt("0x100000000000000000000000000000000"),c=Xt(o*t,n),i=Xt(-r*t,n);let a=H(t-c*e-i*s,n),b=H(-c*r-i*o,n);const l=a>f,B=b>f;if(l&&(a=n-a),B&&(b=n-b),a>f||b>f)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:l,k1:a,k2neg:B,k2:b}}}},yt),St=BigInt(0),le=t=>typeof t=="bigint"&&St<t&&t<Bt,on=t=>typeof t=="bigint"&&St<t&&t<xt,Qt={};function Et(t,...n){let e=Qt[t];if(e===void 0){const r=yt(Uint8Array.from(t,s=>s.charCodeAt(0)));e=K(r,r),Qt[t]=e}return yt(K(e,...n))}const $t=t=>t.toRawBytes(!0).slice(1),Ht=t=>lt(t,32),Ot=t=>H(t,Bt),bt=t=>H(t,xt),Pt=vt.ProjectivePoint,cn=(t,n,e)=>Pt.BASE.multiplyAndAddUnsafe(t,n,e);function Rt(t){let n=vt.utils.normPrivateKeyToScalar(t),e=Pt.fromPrivateKey(n);return{scalar:e.hasEvenY()?n:bt(-n),bytes:$t(e)}}function de(t){if(!le(t))throw new Error("bad x: need 0 < x < p");const n=Ot(t*t),e=Ot(n*t+BigInt(7));let r=ue(e);r%pt!==St&&(r=Ot(-r));const s=new Pt(t,r,ae);return s.assertValidity(),s}function he(...t){return bt(V(Et("BIP0340/challenge",...t)))}function fn(t){return Rt(t).bytes}function an(t,n,e=re(32)){const r=C("message",t),{bytes:s,scalar:o}=Rt(n),f=C("auxRand",e,32),c=Ht(o^V(Et("BIP0340/aux",f))),i=Et("BIP0340/nonce",c,s,r),a=bt(V(i));if(a===St)throw new Error("sign failed: k is zero");const{bytes:b,scalar:l}=Rt(a),B=he(b,s,r),p=new Uint8Array(64);if(p.set(b,0),p.set(Ht(bt(l+B*o)),32),!be(p,r,s))throw new Error("sign: Invalid signature produced");return p}function be(t,n,e){const r=C("signature",t,64),s=C("message",n),o=C("publicKey",e,32);try{const f=de(V(o)),c=V(r.subarray(0,32));if(!le(c))return!1;const i=V(r.subarray(32,64));if(!on(i))return!1;const a=he(Ht(c),$t(f),s),b=cn(f,i,bt(-a));return!(!b||!b.hasEvenY()||b.toAffine().x!==c)}catch{return!1}}const bn={getPublicKey:fn,sign:an,verify:be,utils:{randomPrivateKey:vt.utils.randomPrivateKey,lift_x:de,pointToBytes:$t,numberToBytesBE:lt,bytesToNumberBE:V,taggedHash:Et,mod:H}},un=en(rt,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(n=>BigInt(n)))),ln=We(rt,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:rt.create(BigInt("-11"))}),{hashToCurve:wn,encodeToCurve:gn}=nn(vt.ProjectivePoint,t=>{const{x:n,y:e}=ln(rt.create(t[0]));return un(n,e)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:rt.ORDER,m:1,k:128,expand:"xmd",hash:yt});export{gn as encodeToCurve,wn as hashToCurve,bn as schnorr,vt as secp256k1};
